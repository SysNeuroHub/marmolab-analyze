function [Spike] = trialSpike(o,varargin)

%  loads spike data across trials, onseted to particular trial
%  timepoints
%
% Input:
%   o = mdbase object with LFP data
%
% Optional arguments:
%   channels - channels to load LFP data for (defaut: o.lfp.numChannels)
%   onset - time point to onset data to (ie target onset, stimulus onset, etc) default is trial start
%   onsetvector? - maybe a way of inputing an optional alingment, like
%   saccade times
%   trind = logical vector to tell which trials to use
%   bn - time bin around onset time
%
% Output
%   spike - a cell array of spike times in ms for each trial
%
% 2023-01-05 - Maureen Hagan <maureen.hagan@monash.edu>

% not sure the best way to deal with onsetments. in ns, stimuli and
% behaviours are a bit different. also, saccade times are something
% processed separaetly. to start, this will onset to onset of a simtulus
% and we'll go from there. if no onset given, will onset to firstFrame of
% the trial. 

% also = successful trials arent defined in the marmolab object. so optional
% vector input to account for this.


p = inputParser();
p.KeepUnmatched = true;
p.addParameter('channels',[],@(x) validateattributes(x,{'numeric'},{'positive','>=',min(o.lfp.numChannels),'<=',max(o.lfp.numChannels)}));
p.addParameter('onset','',@(x) ischar(x) || isempty(x));
p.addParameter('bn',[0,1000]); %, @(x) validateattributes(x,{'numeric'},{'positive','==',2))
p.addParameter('onsetvector',[],@(x) validateattributes(x,{'numeric'},{'positive','>=',min(o.lfp.numTrials),'<=',max(o.lfp.numTrials)}));
p.addParameter('trind',[]); %, @(x) validateattributes(x,{'logical'}))

p.parse(varargin{:});

args = p.Results;

if isempty(args.channels), channels = 1:o.spikes.numChannels; end

%find which trials to use
if isempty(args.trind)
    if isprop(o,'complete'), trind = o.complete;
    else, trind = true(1,o.spikes.numTrials);
    end
else, trind = args.trind;
end

% get an onset time in ms for each trial
if isempty(args.onsetvector)
    if ~isempty(args.onset)
    	onsets = o.meta.(args.onset).startTime.time - o.meta.cic.firstFrame.time; % onset time to the nearest s
    else
        onsets = ones(1,o.spikes.numTrials);
    end
else, onsets = args.onsetvector;
end
onsets = onsets(trind);

Spike = cell(1,numel(channels));

trials = 1:o.spikes.numTrials;
trials = trials(trind);
bn = args.bn./1e3;

for ich = channels
    Spike{ich} = cell(1,sum(trind));
    for itr = 1:numel(trials)
        trial = trials(itr);
        start = onsets(itr) + bn(1);
        timestamps = o.spikes.spk{trial} - start;
        ind = find( 
        trialsp = trialsp(trialsp >= args.bn(1) & trialsp <= args.bn(2)); % find spikes within time bin
        Spike{itr, ich} = timestamps(ind).*1e3; % convert to ms at the last minute
    end
end

    for iTr = 1:nTr
        at = getfield(Events,field,{trials(iTr),number});
        start = at+bn(1);
        stop = start+diff(bn)*FS./1e3;
%         disp([num2str(start) ' ' num2str(stop)])
%         if trials(iTr)==100;keyboard;end
        for iCh = 1:nCh
            if ~isempty(clu{ch(iCh)})
                timestamps = clu{ch(iCh)}(:,1)-start;
                clid = clu{ch(iCh)}(:,2);
                ind = find(timestamps > 0 & timestamps < diff(bn));
                spike = [timestamps(ind) clid(ind)];
            end
        end
    end

if numel(channels) == 1 
    Spike = Spike{1};
end

end

