function spikephase = trialSpikeLFPPhase(o,varargin)

% returns the phase of the LFP at the time a spike occurs. This is based on
% the method used in Maureen's paper https://doi.org/10.1038/s41586-022-04631-2

% but is also used to find spike-LFP relationships across depth as shown in
% in Zac Davis' paper: bioRxiv https://doi.org/10.1101/2022.10.26.513932
% this uses the generalized phase method of filtering the LFP. see trialGP
% for more info

% because you get one phase per spike per LFP, the output is a cell array
% number of cells x number of LFPs

% To do > should write something to give the
% option of susbset of channels.

%
% Input:
%   o = mdbase object with Spiking and LFP data
%
% Optional arguments:
%   channels - channels to load LFP data for (defaut: o.lfp.numChannels)
%   onset - time point to onset data to (ie target onset, stimulus onset, etc) default is trial start
%   onsetvector - maybe a way of inputing an optional alingment time points, like
%   saccade times, onseted to start of trial > make sure its in ms from
%   trial start!
%   trind = logical vector to tell which trials to use
%   bn - time bin around onset time
%   method - method for fitlering the LFP - 'GP' for generalized phase,
%   'MT' for multitaper 
%   fk - frequency window for filtering the LFP, [min, max], Zac uses [5,
%   40] in his paper.
%   tapers - [N, W], if using multitaper, need frequency smoothing and time
%   window

%
% Output
%   spikephase - the phase of the LFP at the time of the spike
%
% 2023-01-12 - Maureen Hagan <maureen.hagan@monash.edu>

p = inputParser();
p.KeepUnmatched = true;
p.addParameter('channels',[],@(x) isnumeric(x) || isempty(x));
p.addParameter('onset','',@(x) ischar(x) || isempty(x));
p.addParameter('bn',[0,1000]); %, @(x) validateattributes(x,{'numeric'},{'positive','==',2))
p.addParameter('onsetvector',[],@(x) validateattributes(x,{'numeric'},{'positive','>=',min(o.lfp.numTrials),'<=',max(o.lfp.numTrials)}));
p.addParameter('trind',[]); %, @(x) validateattributes(x,{'logical'}))

% for LFP
p.addParameter('method','GP',@(x) ischar(x) || isempty(x)); % altneratively 'MT'
% parameters for mt filter
p.addParameter('tapers',[0.5,10],@(x) isnumeric(x)); % tapers
p.addParameter('fk',20,@(x) isnumeric(x)); % frequency, can also be a vector
p.addParameter('fs',1e3,@(x) isnumeric(x)); % sampling rate in ms


p.parse(varargin{:});

args = p.Results;

Spike = trialSpike(o,'channels',args.channels,'onset',args.onset,'bn', args.bn, 'onsetvector',args.onsetvector,'trind',args.trind);

switch args.method
    case 'MT'
        [~, lfpPhase] = trialmtLFP(o,'channels',args.channels,'onset',args.onset,'bn', args.bn, 'onsetvector',args.onsetvector,'trind',args.trind, 'tapers',args.tapers,'fk',args.fk,'fs',args.fs);
    case 'GP'
        [~, lfpPhase] = trialGP(o,'channels',args.channels,'onset',args.onset,'bn', args.bn, 'onsetvector',args.onsetvector,'trind',args.trind);
end

nFreq = numel(args.fk);
nCell = length(Spike);
nLFP =  size(lfpPhase,1);
ntr = size(lfpPhase,2);

if nFreq == 1, lfpPhase = reshape(lfpPhase, [1, size(lfpPhase,1), size(lfpPhase,2), size(lfpPhase,3]); end

spikephase = cell(nFreq, nCell, nLFP);

for ifreq = 1:nFreq
    for icell = 1:nCell
        for ilfp = 1:nLFP
            for itr = 1:ntr
                spiketimes = round(Spike{icell}{itr})'; % spike times to the nearest ms
                spiketimes(spiketimes == 0) = 1; % cant have spiketime = 0
                spikephase{ifreq,icell,ilfp}{itr} = squeeze(lfpPhase(ifreq,ilfp,itr,spiketimes))';
            end
        end
    end
end

end

